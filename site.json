{
  "site": {
    "title": "MEAN FAQ",
    "subtitle": "SPA Recipes for any team",
    "author": "David Souther",
    "copyright": "2014"
  },
  "files": {
    "/pages/01_layout/01_areas/index.md": {
      "front": {
        "title": "Project Areas",
        "path": "/pages/01_layout/01_areas/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "The SPA application in a MEAN Stack includes more than the SPA client alone (the HTML and JavaScript running in a browser); it also needs at least an API server. It is sensible to keep project deployment scripts with the main repository. A well tested application will have integration and feature tests mapping to users behaviors; these are not part of the client or server, but should also be with the project.\n"
    },
    "/pages/01_layout/01_areas/01_root/index.md": {
      "front": {
        "title": "Project Root Layout",
        "path": "/pages/01_layout/01_areas/01_root/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "## Problem\n\nThe root of a project easily gets overloaded with intermediate files.\n\n## Solution\n\nThe files in the project root should be limited to editable, project wide configuration, and one folder, `src/`, that all editable source code lives in.\n\n```tree\n% tree -a -L 1 --dirsfirst\n.\n├── .git # Managed by [git][git], for version control.\n├── bower_components #  Managed by [bower][bower], for client-side dependencies.\n├── build # Managed by [grunt][grunt] as part of the build process.\n├── log # Available for writing by the server and libraries at runtime.\n├── node_modules # Managed by [npm][npm] for server and build dependencies.\n├── run # Available for db files and other long-term server persistance.\n├── tmp # Available for PIDs and other short-term server persistence.\n├── src # The project's source code. The only directory whose code can be edited.\n├── .coffeelintrc # Project coffee linting rules.\n├── .jshintrc # Project javascript linting rules.\n├── .jscsrc # Project javascript code style rules.\n├── .gitignore # Project git ignores, which includes above directories.\n├── Gruntfile.coffee # Grunt build configuration (or Gulpfile.js, etc).\n├── README.md # Project README. Should include a brief overview of the project and a quickstart guide, at minimum.\n├── app.js # Backend entry point to the application, by convention.\n├── newrelic.js # DevOps configuration.\n├── bower.json # Configuration for client dependencies.\n└── package.json # Main project configuration, as well as build and server dependencies.\n```\n\n## Discussion\n\nKeeping a clean separation between editable and generated files is critical as an application's codebase grows. In a typical MEAN application, there are folders reserved for dependencies (`bower_components` and `node_modules`), folders for runtime files (`log`, `run`, and `tmp`), folders for intermediate transpilation steps (`build`), and possibly more. Project wide configuration settings (`coffeelint`, `jslint`) apply to every area, and don't need duplicating. Some files are expected by convention: examples being `README.md`, which is used by GitHub & other source control viewers, and `app.js` which is expected for [Phusion Passenger][passenger] and other application monitors.\n\n[git]: http://git-scm.com/\n[bower]: http://bower.io/\n[npm]: http://npmjs.org/\n[grunt]: http://gruntjs.com/\n[passenger]: https://www.phusionpassenger.com/\n"
    },
    "/pages/01_layout/01_areas/02_deploy/index.md": {
      "front": {
        "title": "Deploy Scripts Layout",
        "path": "/pages/01_layout/01_areas/02_deploy/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nA MEAN application has several server-side requirements at runtime, all of which need to be orchestrated.\n\n### Solution\n\nWithin the project's `src` folder, create an area for `deploy`. This will have a folder for each server process that needs to run. Inside those folders, at least a `start.sh` and `stop.sh` should be present. This is a file listing from a project with a Node server backed by a Mongo database.\n\n```tree\n% tree\n.\n└── src\n    ├── client\n    ├── deploy\n    │   ├── Gruntfile.coffee\n    │   ├── env\n    │   │   └── load.sh\n    │   ├── mongo\n    │   │   ├── drop.sh\n    │   │   ├── dump.sh\n    │   │   ├── restore.sh\n    │   │   ├── start.sh\n    │   │   └── stop.sh\n    │   └── node\n    │       ├── start.js\n    │       ├── start.sh\n    │       └── stop.sh\n    ├── features\n    └── server\n```\n\nThe node and mongo server each have a `start.sh` and `stop.sh` script, which manage their individual processes using PIDs written to `./run` in the project root. In this example, the node `start.sh` will call mongo's `start.sh` directly. Both will call `env/load.sh`, which sets several environment variables to control runtime behavior. The `Gruntfile.coffee` is optional, and is for any build-time tasks that need to happen to keep the working directory clean for deployment.\n\nThe mongo server has a few additional scripts to handle database deployment. The drop, dump, and restore scripts all allow for quick migration of data between environments and instances. Node's `start.js` script is a convenient node entry point, though it could have shared that duty with `app.js` in the project root.\n\n### Discussion\n\nWhile the sample app only has a mongo and a node server, any server process which needs start and stop before the application is running can go here. Having a consistent set of shell scripts for deploying pieces of a stack eases development long term. Sysops teams have a consistent way to interact with the application. This consistency helps new devs quickly troubleshoot any changes they might need to make to the runtime setup. Having these scripts in their own area of the project allows the technologies to grow, seperately from any one portion of the source code itself. For more details on what to put in these scripts, see the chapter on [deployment][deployment].\n\n[deployment]: /03_deployment\n"
    },
    "/pages/01_layout/01_areas/03_server/index.md": {
      "front": {
        "title": "Server Layout",
        "path": "/pages/01_layout/01_areas/03_server/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nComponents in an Express application have several types of modules.\n\n### Solution\n\n```tree\n.\n└── src\n    ├── client\n    ├── deploy\n    ├── features\n    └── server\n        ├── Gruntfile.coffee\n        ├── db.coffee\n        ├── logger.coffee\n        ├── routers.coffee\n        ├── server.coffee\n        ├── test.coffee\n        ├── api\n        │   └── route.coffee\n        ├── auth\n        │   ├── authenticate.coffee\n        │   ├── google.coffee\n        │   ├── mock.coffee\n        │   ├── route.coffee\n        │   └── signout.coffee\n        ├── hunts\n        │   ├── model.coffee\n        │   ├── route.coffee\n        │   └── test.coffee\n        ├── leaders\n        │   └── route.coffee\n        ├── static\n        │   ├── handler.coffee\n        │   └── test.coffee\n        ├── students\n        │   ├── model.coffee\n        │   ├── route.coffee\n        │   └── test.coffee\n        └── submissions\n            ├── loader\n            │   └── import.coffee\n            ├── model.coffee\n            ├── route.coffee\n            ├── runner\n            │   ├── runner.coffee\n            │   └── test.coffee\n            └── test.coffee\n```\n\nIn this project, the entry point is through `server.coffee`. It will load the various configurations, wire the necessary handlers, and generally perform the server's base setup. Then, each component will have its own set of files to perform specific server tasks. Some are pertinent to the application, like `students` and `submissions`. Some are general to an area of business concern, like the `auth` folder. These all have a few key pieces in common, but that is only by convention.\n\nAny file named `handler`, by convention, returns a middleware factory. A middleware factory is a function that takes a configuration object, and returns an express middleware function. See the chapter on [servers][server] for more. A file named `route`, by convention, exports a function that takes an Express application and attaches routes to that app. Files called `model` can export an ORM model definition (see [restify][restify] for an example). Files named `test` define [mocha tests][mocha_server] for that server component. Any other file can be created for a component as needed.\n\nBusiness orthagonal pieces also exist, but can generally be considered part of the same component structure. The `auth` component, which ties in to passport, is a great example in this project.\n\n### Discussion\n\nBoth the Server and Client share a code layout inverted to a traditional Rails or J2EE application. Where those systems create folders by file or module type (controllers, views, etc), build configurations today are simple enough to use the more sensible approach outlined here. The server folder is split for each component, allowing some knowledge of the hierarchy of the project into the server folder structure itself. This keeps all of the pieces together - no hunting between a tests folder and into some model definitions two pages and four directories away.\n\nImplementing this approach is very straightforward in code, because of Node's common js module loading system. With the `[require][node_require]` function, node will intelligently look either for a library installed in `node_modules`, or will look relative to the current script for a loadable file. By default, node understands `.js` and `.json` files, but has mechanisms to load handlers for many other defined file types. After installing coffeescript for a project, calling `require('coffee-script/register')` in the application's main script will install the `.coffee` handler.\n\nLooking more closely at the `students` component, we can see all this in action. First, in `routers.coffee` in the server root, we load the various routers we need for our components. It has a list of routable components, loads each, and passes the `app` to them. Notice that it itself is a router, and exports a function that takes an app object.\n\n```coffeescript\nrouters = (app)->\n    [\n        'auth'\n        'students'\n        'leaders'\n        'hunts'\n        'submissions'\n\n        'api'\n    ].forEach (api)->\n        require(\"./#{api}/route\")(app)\n\n    app\n\nmodule.exports = routers\n```\n\nThe students router merely loads the model and attaches it to the `app`, with some logging.\n\n```coffeescript\nwinston = require('../logger').log\nrestify = require('express-restify-mongoose').serve\n\nStudent = require('./model')\n\nroute = (app)->\n    winston.silly 'Attaching students routes...'\n    restify app, Student\n\nmodule.exports = route\n```\n\nFinally, the students `model.coffee` defines the model characteristics in the ORM.\n\n```coffeescript\nmongoose = require('../db')\n\nSchema = mongoose.Schema\nstudentSchema = Schema({\n    name: String\n    email: String\n    token: String\n    roles: {\n        teacher: Boolean\n    }\n})\nStudent = mongoose.model 'student', studentSchema\n\nStudent.expandName = (name)->\n    [name, first, last] = name.match /([A-Z][a-z]+)([A-Z].*)/\n    \"#{first} #{last}\"\n\nmodule.exports = Student\n```\n\nThe common thread among these files is the relative pathing in the `require` statements. Because node is very intelligent about both the distinction between local and library pathing, and in understanding file types to load. This allows tools like coffeescript to register handlers in the node environment, load those files at runtime, and interoperate between any supported file type. The project is free to lay out its files however it wishes. Choosing this component-first approach is a good way to organize your project, but so long as the approach is consistent, a project will do fine.\n\n[server]: /07_server\n[restify]: /07_server/03_mongo/03_restify\n[mocha_server]: /02_testing/01_server\n[node_require]: http://nodejs.org/api/modules.html\n"
    },
    "/pages/01_layout/01_areas/04_client/index.md": {
      "front": {
        "title": "Client Layout",
        "path": "/pages/01_layout/01_areas/04_client/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nComponents in an Angular application have several ways to fit into Angular's module loading system.\n\n### Solution\n\n```tree\n.\n└── src\n    ├── client\n    │   ├── Gruntfile.coffee\n    │   ├── index.jade\n    │   ├── main\n    │   │   ├── all.styl\n    │   │   ├── footer\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── template.jade\n    │   │   │   └── test.coffee\n    │   │   ├── login\n    │   │   │   ├── all.styl\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── template.jade\n    │   │   │   └── test.coffee\n    │   │   ├── main.coffee\n    │   │   ├── nav\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── template.jade\n    │   │   │   └── test.coffee\n    │   │   ├── print.styl\n    │   │   ├── screen.styl\n    │   │   └── test.coffee\n    │   ├── scavenge\n    │   │   ├── gradebook\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── service.coffee\n    │   │   │   ├── service.mock.coffee\n    │   │   │   ├── service.test.coffee\n    │   │   │   └── template.jade\n    │   │   ├── hunts\n    │   │   │   ├── all.styl\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── directive.test.coffee\n    │   │   │   ├── edit\n    │   │   │   │   ├── directive.coffee\n    │   │   │   │   ├── template.jade\n    │   │   │   │   └── test.coffee\n    │   │   │   ├── service.coffee\n    │   │   │   ├── service.mock.coffee\n    │   │   │   ├── service.test.coffee\n    │   │   │   └── template.jade\n    │   │   ├── leaders\n    │   │   │   ├── all.styl\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── template.jade\n    │   │   │   └── test.coffee\n    │   │   ├── students\n    │   │   │   ├── directive.coffee\n    │   │   │   ├── screen.styl\n    │   │   │   ├── service.coffee\n    │   │   │   ├── template.jade\n    │   │   │   └── test.coffee\n    │   │   └── submit\n    │   │       ├── controller.coffee\n    │   │       ├── controller.test.coffee\n    │   │       ├── directive.coffee\n    │   │       ├── directive.test.coffee\n    │   │       ├── grading\n    │   │       │   ├── controller.coffee\n    │   │       │   ├── directive.coffee\n    │   │       │   ├── screen.styl\n    │   │       │   └── template.jade\n    │   │       ├── screen.styl\n    │   │       ├── service.coffee\n    │   │       ├── service.mock.coffee\n    │   │       ├── service.test.coffee\n    │   │       └── template.jade\n    │   ├── stylus\n    │   │   └── definitions\n    │   │       ├── mixins.styl\n    │   │       └── variables.styl\n    │   ├── tools\n    │   │   └── render.coffee\n    │   └── util\n    │       ├── fileInput\n    │       │   ├── directive.coffee\n    │       │   ├── service.coffee\n    │       │   └── test.coffee\n    │       └── thsort\n    │           ├── directive.coffee\n    │           ├── screen.styl\n    │           └── template.jade\n    ├── features\n    └── server\n```\n\nSimilar to the [server layout][server_layout], the client code is separated along component seams, rather than module type seams. The main entry point to the application is `index.jade`, which should be compiled as-is and returned as a static asset on any page load. Each component then has a `template.jade` file, which will be compiled and injected into Angular's template loading system. The stylus files are broken into three types, for the three media queries `all`, `print`, and `screen`.  This lets your app have a quick and easy way to define many styles for various media. The coffee files are compiled individually, then concatenated in order. That order is not terribly important, as each file will define a module to be loaded at runtime.\n\n### Discussion\n\nThere are many ways to turn this directory structure into served code on the client. [Grunt][gruntjs] is the most popular JS build tool, though many others are also capable. These tools take the source directory, pass it through a series of transformations, and store the finished file elsewhere in the project structure (usually `build/`). Other tools, like [stassets][stassets], work as an express middleware. Because they operate entirely in memory and don't write to disk, these are much faster; however, they generally offer less flexibility. Stassets is built to handle project structures like this one.\n\nA base Gruntfile could look like this.\n\n```coffeescript\nmodule.exports = (grunt)->\n    flatten = (a, b)-> a.concat b\n\n    module = 'teals.scavenger'\n\n\n    ###\n    This array defines watch patterns for the application's client files.\n    Templates must be in jade format; services, controllers, directives, etc are\n    coffee. Any other files, like providers or custom model modules, could be\n    added here.\n    ###\n    appFileOrdering = [\n        '**/template.jade'\n        '**/main.coffee'\n        '**/service.coffee'\n        '**/controller.coffee'\n        '**/directive.coffee'\n    ].map((a)->\"src/client/#{a}\").reduce flatten, []\n\n\n    ###\n    grunt.Config is a convenience property defined in `grunt-recurse`. It allows\n    gruntfiles to be more iterative in defining their configuartion.\n    ###\n    grunt.Config =\n        ###\n        With `grunt watch:client`, watch any client files, including tests.\n        ###\n        watch:\n            client:\n                files: [\n                    'src/client/**/*.js'\n                    'src/client/**/*.coffee'\n                    'src/client/**/*.jade'\n                    'src/client/**/*.styl'\n                ]\n                tasks: [\n                    'client'\n                ]\n                options:\n                    spawn: false\n\n        ###\n        Jade itself only compiles the index.\n        ###\n        jade:\n            index:\n                files: {\n                    'build/client/index.html': ['src/client/index.jade']\n                }\n        ###\n        ng-jade is a custom jade compiler, that injects the compiled jade\n        html into an angular module, in this case, named `teals.templates`. Any\n        angular directive that specifies a `templateUrl` can specify the folder\n        path to the file, eg the `**` portion of the `src` pattern, to load the\n        rendered HTML.\n        ###\n        ngjade:\n            templates:\n                files: [{\n                    expand: false\n                    src: ['src/client/**/template.jade']\n                    dest: 'build/client/templates.js'\n                }]\n                options:\n                    moduleName: 'teals.templates'\n                    processName: (filepath)->\n                        r_template = /^src\\/client\\/(.*)\\/template.(html|jade)$/\n                        path = filepath.replace r_template, '$1'\n                    newModule: true\n        ###\n        There are three types of stylus targets, one for each of `all` media\n        types, `screen` media types, and `print` media types. Adding more stylus\n        targets, eg for `braile` or other css media types, is perfectly fine.\n        ###\n        stylus:\n            options:\n                paths: [\n                    'src/client/stylus/definitions'\n                ]\n                import: [\n                    'mixins'\n                    'variables'\n                    'nib'\n                ]\n            all:\n                files:\n                    'build/client/all.css': \"src/client/**/all.styl\"\n            print:\n                files:\n                    'build/client/print.css': \"src/client/**/print.styl\"\n            screen:\n                files:\n                    'build/client/screen.css': \"src/client/**/screen.styl\"\n\n        ###\n        Two sets of files get copied as-is: the client assets, and the needed\n        vendor files out of bower_components. The bower_components could also\n        use `grunt-contrib-concat` to build a compiled `vendors.js`.\n        ###\n        copy:\n            client:\n                files: [\n                    expand: true\n                    cwd: 'src/client'\n                    src: ['index.html', 'assets/**/*']\n                    dest: 'build/client'\n                ]\n            vendors:\n                files: [\n                    expand: true\n                    cwd: 'bower_components'\n                    src: [\n                        'angular/angular.*'\n                        'angular-route/angular*'\n                        'angular-cookies/angular*'\n                        'angular-resource/angular*'\n                        # 'angular-ui/build/**/*'\n                        'bootstrap/dist/**/*'\n                        'angular-bootstrap/**/*'\n                        'angular-ui-codemirror/**/*'\n                        'codemirror/**/*'\n                        'css-social-buttons/css/*'\n                    ]\n                    dest: 'build/client/vendors'\n                ]\n\n        ###\n        All the application coffee scripts are joined and compiled in order. The\n        angular module definition tools are used to manage client internal\n        dependencies.\n        ###\n        coffee:\n            options:\n                bare: false\n                join: true\n            client:\n                files:\n                    'build/client/app.js': appFileOrdering\n                        .filter (file)-> file.match(/\\.coffee$/)\n\n    grunt.registerTask 'buildClient',\n        'Prepare the build/ directory with static client files.',\n        [\n            'copy:client'\n            'copy:vendors'\n            'ngjade:templates'\n            'jade:index'\n            'coffee:client'\n            'stylus'\n        ]\n\n    grunt.registerTask 'client',\n        'Prepare and test the client.',\n        [\n            'testClient' # See the section on Angular in the Testing chapter\n            'buildClient'\n        ]\n```\n\nThis Gruntfile is fully featured and used in several projects. It takes `src/client`, and builds those to this.\n\n```tree\nbuild/client\n├── all.css\n├── app.js\n├── index.html\n├── print.css\n├── screen.css\n├── templates.js\n└── vendors\n    ├── angular\n    │   ├── angular.js\n    │   ├── angular.min.js\n    │   ├── angular.min.js.gzip\n    │   └── angular.min.js.map\n    ├── angular-bootstrap\n    │   ├── bower.json\n    │   ├── ui-bootstrap-tpls.js\n    │   ├── ui-bootstrap-tpls.min.js\n    │   ├── ui-bootstrap.js\n    │   └── ui-bootstrap.min.js\n    ├── angular-cookies\n    │   ├── angular-cookies.js\n    │   ├── angular-cookies.min.js\n    │   └── angular-cookies.min.js.map\n    ├── angular-resource\n    │   ├── angular-resource.js\n    │   ├── angular-resource.min.js\n    │   └── angular-resource.min.js.map\n    ├── angular-route\n    │   ├── angular-route.js\n    │   ├── angular-route.min.js\n    │   └── angular-route.min.js.map\n    ├── angular-ui-codemirror\n    │   ├── ui-codemirror.js\n    │   └── ui-codemirror.min.js\n    ├── bootstrap\n    │   └── dist\n    │       ├── css\n    │       │   ├── bootstrap-theme.css\n    │       │   ├── bootstrap-theme.css.map\n    │       │   ├── bootstrap-theme.min.css\n    │       │   ├── bootstrap.css\n    │       │   ├── bootstrap.css.map\n    │       │   └── bootstrap.min.css\n    │       ├── fonts\n    │       │   ├── glyphicons-halflings-regular.eot\n    │       │   ├── glyphicons-halflings-regular.svg\n    │       │   ├── glyphicons-halflings-regular.ttf\n    │       │   └── glyphicons-halflings-regular.woff\n    │       └── js\n    │           ├── bootstrap.js\n    │           └── bootstrap.min.js\n    ├── codemirror\n    │   ├── lib\n    │   │   ├── codemirror.css\n    │   │   └── codemirror.js\n    │   ├── mode\n    │   │   └── python\n    │   │       └── python.jss\n    │   └── theme\n    │       └── monokai.css\n    └── css-social-buttons\n        └── css\n            ├── zocial-regular-webfont.eot\n            ├── zocial-regular-webfont.svg\n            ├── zocial-regular-webfont.ttf\n            ├── zocial-regular-webfont.woff\n            └── zocial.css\n```\n\nIf the build file chose to minify the vendors, rather than copying them, the build would be even smaller.\n\n[server_layout]: /01_layout/01_areas/03_server\n[stassets]: https://www.npmjs.org/package/stassets\n[gruntjs]: http://gruntjs.org\n"
    },
    "/pages/01_layout/index.md": {
      "front": {
        "title": "Project Layout",
        "path": "/pages/01_layout/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\n\n\n### Solution\n\nChoosing a project layout has a surprising number of consequences for a team. The Java approach and conventional wisdom separates projects along language and environment seams. There are separate folders for `main/` and `test/`, and separate folders for language, `src/scala/com/...` and `src/java/...`. Rails and Rails-like stacks split the project along OO seams, creating different directories for `app/` and `test/`. Inside `app/` and `test/` are folders for `controllers/` and `templates/`. These approaches place the framework concepts front and center, forcing developers to think about the tools first and the business model second. To go from a controller to a template requires navigating up and then back down the directory structure.\n\nA better conceptual approach is to break the application along business model seams. There are good reasons for doing so: for one, it places the conceptual model of the business itself at the forefront of development. This allows for easier mixing & matching of the various transpiled languages. Putting the business model and logic first builds in an ubiquitous language for the project, a useful concept from the field of Domain Driven Development. Team members see their business components first, and talk about the specific controller, schema, or template later. While mixing languages makes the build tools require more configuration, it usually falls to the difference in moving `coffee/**` to `**/*.coffee`. Teams can choose languages that are most comfortable to their style concerns.\n\nAfter building a sensible project layout, teams can choose which of the various transpiled programming languages to use for various types of code. Broadly, the codebase has: scripts, bits of executable code; markup, declarations that will create the DOM structure; and styling, declarations to style portions of the DOM. These script types will need to be coordinated through a build system. Because SPAs are served as a collection of a half-dozen minified, compressed, cacheable files, this build process is the link between your one-module-per-file source directory, and your final `application.js` file.\n\n### [Areas](./01_areas)\n\nBefore building the SPA, I recommend breaking your source code into four primary areas, within the root of your project. The first five recipes describe each of these areas -- what they're used for, what types of files live in them, and a recommended layout for components inside those modules.\n\n1. **[Root](./01_areas/01_root)**\n1. **[Deploy](./01_areas/02_deploy)**\n1. **[Server](./01_areas/03_server)**\n1. **[Client](./01_areas/04_client)**\n1. **[Features](./01_areas/05_features)**\n\n### Languages\n\n1. **script**: *JavaScript* vs *Coffee* vs *Dart*\n1. **markup**: *HTML* vs *Jade*\n1. **styling**: *css* vs *Stylus* vs *SASS* vs *Less*\n\n### Build Toolchain\n\n1. **Grunt** *Task Configuration*\n1. **Gulp** *Build Pipelines*\n1. **Closure Compiler** *Static type safety*\n\n### Static Typing\n"
    },
    "/pages/02_testing/index.md": {
      "front": {
        "title": "Testing",
        "path": "/pages/02_testing/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "Testing is a great, sane technique for developers to have confidence in their code. While learning how to test can be daunting to many teams, the community support and tooling for testing in the MEAN world is sublime. Teams don't have to test first, but with the techniques in this chapter, they can test when they want. These recipes cover all levels of the SPA stack, from unit testing through full user integration and regression tests, with code coverage tools along the way.\n\n### Server\n1. **Supertest**\n1. **Logging**\n1. **Coverage**\n\n### [Angular](/02_testing/02_angular)\n\nAngular was built from the ground up to be testable by developers who fundamentally belive in the power of testability. As such, Angular provides many features and libraries that ease testing, as well as being designed in a way that testing fits in well with development. The most common testing scenarios have recipes here, and other tests are provided throughout the book. Before diving in to these recipes, feel free to familiarize yourself with the [testing gruntfile](/02_testing/02_angular).\n\n1. **[$httpBackend](/02_testing/02_angular/01_httpBackend)**\n1. **[Managing Injections](/02_testing/02_angular/02_injections)**\n1. **[Rendering Directives](/02_testing/02_angular/03_rendering)**\n1. **[Coverage](/02_testing/02_angular/04_coverage)**\n\n### Integration / Feature\n1. **cucubmberjs**, *qcumber*, *qcumberbatch*\n1. **Mappings Model**\n\n### BDD / TDD\n1. **Writing Failing Features**\n1. **Writing Failing Server Tests**\n1. **Writing Failing Client Tests**\n"
    },
    "/pages/02_testing/01_server/index.md": {
      "front": {
        "path": "/pages/02_testing/01_server/index.md",
        "title": "02_testing01_server",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/02_testing/02_angular/index.md": {
      "front": {
        "title": "Testing Angular",
        "path": "/pages/02_testing/02_angular/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nA single page application made of many components requires each component to be\ntested in isolation, and across many platform targets.\n\n### Solution\n\nUtilizing the [karma][karma] test runner tool, a project that makes full use of\nAngular's modules can be easily tested to whatever granularity is needed by the\ntester. Starting from the configuration we have in the\n[client layout](/01_layout/01_areas/04_client), add these configuration settings\nfor Karma.\n\n```coffeescript\ngrunt.Config =\n    # ...\n\n    browsers = []\n    unless process.env['DEBUG']\n        if process.env['BAMBOO']\n            browsers = ['PhantomJS']\n        else\n            browsers = ['Chrome']\n\n    preprocessors =\n        'src/client/**/*test.coffee': [ 'coffee' ]\n        'src/client/**/*mock.coffee': [ 'coffee' ]\n        'src/client/tools/*.coffee': [ 'coffee' ]\n        'src/client/**/*.jade': [ 'jade', 'ng-html2js' ]\n\n    cover =\n        if process.env.DEBUG and not process.env.COVER\n            'coffee'\n        else\n            'coverage'\n\n    for type in appFileOrdering\n        if type.indexOf('.coffee') > -1\n            preprocessors[type] = [cover]\n\n\n    ###\n    After defining a few properties, including whether to run coverage\n    preprocessors, grunt-recurse's Config property allows us to continue adding\n    config definitions.\n    ###\n    grunt.Config =\n        karma:\n            ###\n            Configure Karma to run mocha tests on the project.\n            ###\n            client:\n                options:\n                    browsers: browsers\n                    frameworks: [ 'mocha', 'sinon-chai' ]\n                    reporters: [ 'spec', 'junit', 'coverage' ]\n                    singleRun: true,\n                    logLevel: 'INFO'\n                    ###\n                    Preprocessors include ng-jade, coverage, etc.\n                    ###\n                    preprocessors: preprocessors\n                    files: [\n                        # 'bower_components/jquery/jquery.js'\n                        'bower_components/angular/angular.js'\n                        'bower_components/angular-route/angular-route.js'\n                        'bower_components/angular-resource/angular-resource.js'\n                        # 'bower_components/angular-animate/angular-animate.js'\n                        'bower_components/angular-cookies/angular-cookies.js'\n                        'bower_components/angular-mocks/angular-mocks.js'\n                        'src/client/**/*mock.coffee'\n                        'src/client/tools/**/*'\n                        appFileOrdering\n                        grunt.expandFileArg('src/client', '**/')\n                    ].reduce(flatten, [])\n                    ngHtml2JsPreprocessor:\n                        cacheIdFromPath: jadeTemplateId\n                        moduleName: 'teals.templates'\n                    junitReporter:\n                        outputFile: 'build/reports/karma.xml'\n                    coverageReporter:\n                        type: 'lcov'\n                        dir: 'build/reports/coverage/'\n\n    grunt.registerTask 'testClient',\n        'Run karma tests against the client.',\n        [\n            'karma:client'\n        ]\n\n```\n\n### Discussion\n\nThere are a few points to highlight in this configuration. First, the browser is\ndynamically chosen depending on environment variables. This lets developers run\n`DEBUG=1 grunt test`, which will open no browser, and let them connect\nthemselves; or just run `grunt test`, and get Chrome (`google-chrome` will need\nto be in `PATH`); or with `BAMBOO=1 grunt test` will assume it's on a CI server\nand skip straight to headless PhantomJS.\n\nThis particular configuration will load all the files it finds for your app (via\n`appFileOrdering`), all the tests and mocks files (`src/client/**/*mock.coffee`\nand `grunt.expandFileArg('src/client', '**/')`), and finally, any other tools\nneeded for stubbing out test services (`'src/client/tools/**/*'`). That last one\nwe'll look at more closely in some other sections.\n\nThis configuration uses [mocha][mocha] for the testing library (for `describe`,\n`it`, `beforeEach`, etc), [chai][chai] for the assertions library (take your\nchoice of `assert`, `expect`, or `should`), and [sinon][sinon] to provide spies\nand stubs. Karma is very configurable, having plugins that we use here for\nrendering templates, providing reports from the command line to jUnit, and\ninstrumenting our code (when requested) with [ibrik][ibrik] coverage reporting.\n\nThe `src/client/tools/` folder is treated specially. It is not part of your\ndelivered project specifically, but provides a place to put extra mock and stub\ncode your project will use. We use it in the sections on\n[httpBackend](./01_httpBackend) and [rendering](03_rendering), with a full\nexplanation in [injections](02_injections). Saving details on the code for then,\nstart a file in that folder called `backend.coffee`, and put a basic mocks guard\nin.\n\n```coffeescript\n# src/client/tools/backend.coffee\n\nif angular.mock\n    window.httpBackend = angular.mock.httpBackend = (data, afterEach = ->)->\n```\n\nWe'll fill that out the method body next section. This method, `httpBackend`,\nwill be available only if we're mocking code out (as indicated by angular.mock\nbeing defined). We also export it on the window, in the mocking environment, for\nconvenience. This is the one exceptional case where globals are sane and useful.\n\nkarma: http://karma-runner.github.io/0.12/index.html\nmocha: http://visionmedia.github.io/mocha/\nchai: http://chaijs.com/\nsinon: http://sinonjs.org/\nibrik: https://github.com/Constellation/ibrik\n"
    },
    "/pages/02_testing/02_angular/01_httpBackend/index.md": {
      "front": {
        "title": "Testing with `$httpBackend`",
        "path": "/pages/02_testing/02_angular/01_httpBackend/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nTesting rich-data services and components requires data from a server resource.\n\n### Solution\n\nAngular provides `$httpBackend` as a testing service to mock HTTP requests in an application. With the component-first code layout we use, the data for these tests lives side by side the services that consume it. This documents your expected wire format directly with the code that consumes it.\n\n```tree\nsrc/client\n└── site\n    ├── controller.coffee\n    ├── controller.test.coffee\n    ├── provider.coffee\n    ├── provider.test.coffee\n    └── site.mock.coffee\n```\n\nThis component, the `site` from [flipflops][flipflops], holds the in-memory representation of a full CMS website. The provider works as a configurable service factory. This application defines its CMS data as an object with a key `site` containing overall site metadata, and a key `files` which is a hash of path to post and page data. This is the data that comes over the wire. After it's loaded, the service builds several convenience indexes. It also provides some utility accessors. The data for this is speced out in `site.mock.coffee`.\n\n```coffeescript\nangular.module('flipflops.site.mock', [])\n.value 'SiteMock', '/site.json': JSON.stringify\n    site :\n        title: \"FlipFlops\",\n        subtitle: \"Quit blogging. Go to the beach.\",\n        author: \"David Souther (DEVELOPMENT)\"\n    files:\n        '/pages/01_chapter/01_section/index.markdown':\n            front:\n                title: 'Chapter 1 Section 1'\n                path: '/pages/01_chapter/01_section/index.markdown'\n            body: \"\"\"Some text for chapter 1 section 1.\"\"\"\n        '/pages/01_chapter/02_section/index.md':\n            front:\n                title: 'Chapter 1 Section 2'\n                path: '/pages/01_chapter/02_section/index.md'\n            body: \"\"\"Some text for chapter 1 section 2.\"\"\"\n        '/pages/01_chapter/index.md':\n            front:\n                title: 'Chapter 1 Intro'\n                path: '/pages/01_chapter/index.md'\n            body: \"\"\"Some text for chapter 1 Intro.\"\"\"\n        '/pages/02_chapter/01_section/index.md':\n            front:\n                title: 'Chapter 2 Section 1'\n                path: '/pages/02_chapter/01_section/index.md'\n            body: \"\"\"Some text for chapter 2 section 1.\"\"\"\n        '/pages/02_chapter/02_section/index.md':\n            front:\n                title: 'Chapter 2 Section 2'\n                path: '/pages/02_chapter/02_section/index.md'\n            body: \"\"\"Some text for chapter 2 section 2.\"\"\"\n        '/pages/02_chapter/index.md':\n            front:\n                title: 'Chapter 2 Intro'\n                path: '/pages/02_chapter/index.md'\n            body: \"\"\"Some text for chapter 2 Intro.\"\"\"\n```\n\nTo mock the data, we first define a new angular module `flipflops.site.mock`. That module has one export, a `value` to be injected for the test as `SiteMock`. That value has a key/value mapping of http endpoints to strings of JSON data. Those keys are then available to inject into the provider test.\n\n```coffeescript\ndescribe 'Site', ->\n    describe 'Service', ->\n        beforeEach module 'flipflops.site', 'flipflops.site.mock'\n\n        $httpBackend = null\n        beforeEach -> inject (_$httpBackend_)->$httpBackend = _$httpBackend_\n        beforeEach -> inject (SiteMock)-> httpBackend SiteMock, afterEach\n\n        it 'sets basic metadata', inject (Site)->\n            $httpBackend.flush()\n            Site.title.should.equal 'FlipFlops', 'Title'\n            Site.author.should.equal 'David Souther (DEVELOPMENT)', 'Author'\n\n        describe 'page', ->\n            it 'generates good page indexes', inject (Site)->\n                index = [\n                    '/pages/01_chapter/index.md'\n                    '/pages/01_chapter/01_section/index.markdown'\n                    '/pages/01_chapter/02_section/index.md'\n                    '/pages/02_chapter/index.md'\n                    '/pages/02_chapter/01_section/index.md'\n                    '/pages/02_chapter/02_section/index.md'\n                ]\n\n                $httpBackend.flush()\n                Site.index.should.exist\n                Site.index.should.have.property('pages')\n                Site.index.pages.length.should.equal 6\n                Site.index.pages.should.deep.equal index\n```\n\nThis test is a good layout for backend tests. It begins with declaring dependencies on the modules `flipflops.site` and `flipflops.site.mock`. The second is that module we just defined with the mock data. It then injects the $httpBackend to a script local variable. Finally, it passes the `httpBackend` helper (see the [overview](/02_testing/02_angular) on angular testing) the url/data mappings from the mock, before continuing on to the actual tests.\n\nBoth tests inject the `Site`, as exported from `flipflops.site`, to the `it` test block. Both start with flushing the http cache. Because each module is reloaded on each new describe block, this give the test writer control over when the `$http` services will be executed. This then allows tests to assert on both pre and post request state. Finally, both tests run through some basic assertions.\n\n### Discussion\n\nThe `$httpBackend` service is one of several modules provided by the Angular team to ease testing. Its `flush()` method, along with similar methods on `$timeout` and other async services, make testing much simpler by creating explicit flow constructs around asynchronous code. Given JavaScript's implicit single-threaded nature, this approach is not frought with the concurrency perils other languages might face.\n\nThe only piece of magic left for the solution is the implementation of the httpBackend method stubbed out in the [last section](../). It's full code should be these few lines:\n\n```coffeescript\n# src/client/tools/\nif angular.mock\n    window.httpBackend = angular.mock.httpBackend = (data, afterEach = ->)->\n        inject ($httpBackend)->\n            for path, val of data\n                $httpBackend.whenGET(path).respond(200, val)\n            afterEach ->\n                $httpBackend.verifyNoOutstandingExpectation()\n                $httpBackend.verifyNoOutstandingRequest()\n\n```\n\nThis uses `$httpBackend::whenGET` to create an http 200 response for each defined endpoint. The $httpBackend service has much more configuration possible, including rudimentary routing and path matching, any HTTP status code, and asserion on `POST` and `GET` parameters. The [documentation][httpBackendDocs] is a great place to go when building tests needing more advanced HTTP mocking.\n\nflipflops: https://github.com/DavidSouther/flipflops\nhttpBackendDocs: https://docs.angularjs.org/api/ngMock/service/$httpBackend\n"
    },
    "/pages/02_testing/02_angular/02_injections/index.md": {
      "front": {
        "path": "/pages/02_testing/02_angular/02_injections/index.md",
        "title": "02_testing02_angular/02_injections",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/02_testing/02_angular/03_rendering/index.md": {
      "front": {
        "path": "/pages/02_testing/02_angular/03_rendering/index.md",
        "title": "02_testing02_angular/03_rendering",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/02_testing/02_angular/04_coverage/index.md": {
      "front": {
        "path": "/pages/02_testing/02_angular/04_coverage/index.md",
        "title": "02_testing02_angular/04_coverage",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/03_deployment/index.md": {
      "front": {
        "title": "Deployment",
        "path": "/pages/03_deployment/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "Deployment for many can be a black box, something handled by the SysOps team and never shall the Devs and Ops meet. While this has worked for many teams and organizations, the experiences and successes of continuous integration at places like Etsy speak to the benefits of a DevOps culture. These recipes provide techniques to handle the deployment of each of the main pieces of the MEAN stack. They also provide a template for orchestrating much larger and more complex deployments.\n\n1. **Node** *Install*, *Start*, *Stop*\n1. **Mongo** *Install*, *Start*, *Stop*, *Snapshot*, *Restore*, *Drop*\n1. **Managing Environment vars**\n1. **Blue / Green / Round**\n1. **Docker**\n1. **Heroku**\n"
    },
    "/pages/04_client/01_organization/index.md": {
      "front": {
        "title": "AngularJS Module Organization",
        "path": "/pages/04_client/01_organization/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nAngularJS has a specific module layout, using terminology that is not\nimediateley intuitive to developers from other projects.\n\n### Solution\n\nIn this section, we'll go through each of the AngularJS `module` methods,\ndiscuss what they are for, and look at their best practices.\n\nModules themselves are little different from any other module system - a module\nhas a name, a (possibly empty) dependency list, and whatever symbols it defines.\nThose definitions are limited, but provide a well-demonstrated set of component\ntypes. We'll explore those in each of the parts of this section.\n\nThere are two approaches to organizing modules. Most applications start with the\nall-in-one approach, defining a single module name for all the app code and\nfilling it with all the components necessary. This approach does not scale.\nPreferred is a one module per file approach, with module names inferred from\n(but not mandated by) the folder structure. In this approach, each module name\nhas the form `app.component.subcomponent.piece`, where `app` is the name of the\napp as whole, `component` and `subcomponent` match the folder structure in the\n`src/client/` part of the project, and `piece` is [`service`](./01_services),\n[`controller`](./02_controllers), [`directive`](./03_directives),\n[`filter`](./04_filters), or [`provider`](./05_providers). This full string is\nthe name other modules will use to load the module.\n\nIn this format, a project's file headers begin to look similar to a Java class\ndefinition or Python import section. This sample, from [FlipFlops][flipflops],\nmanages a `page` of a website as a whole, with sections for the header, footer,\ncontent, etc.\n\n```coffeescript\nangular.module('flipflops.page.directive', [\n    'flipflops.site.controller'\n    'flipflops.page.banner.directive'\n    'flipflops.page.navigation.directive'\n    'flipflops.page.sidebar.directive'\n    'flipflops.page.footer.directive'\n\n    'flipflops.content'\n\n    'page.template'\n]).directive 'ffPage', ->\n    restrict: 'AE'\n    templateUrl: 'page'\n```\n\nThe first line declares what the module name is, for others to use. The next\nfew lines list its dependencies. In this case, it's mostly directives, with a\ncontroller, template, and server thrown in for good measure. The templates have\ntheir own convention with module naming (dropping the app name), this is\nenforced for this app at the build level. See the\n[sample gruntfile](/01_layout/01_areas/04_client) for more details.\n\n[flipflops]:\n"
    },
    "/pages/04_client/01_organization/01_services/index.md": {
      "front": {
        "title": "Angular Services",
        "path": "/pages/04_client/01_organization/01_services/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nComplex applications require a strong, consistent data model, something often\nmissing in traditional web development.\n\n### Solution\n\nAngular Services will be the bread and butter of your data model. Angular\nimplements services as data factories - each service will be instantiated\nexactly once. This instance is responsible for managing a certain set of your\ndata. Let's see this in action.\n\n```coffeescript\nACTIVITY_WINDOW = 20#minutes\n\nclass Activity\n    constructor: (data)->\n        angular.extend @, data\n        @timestamp = Date.parse @timestamp\n\n    isInScope: ->\n        earliest = new Date (new Date()).setMinutes -ACTIVITY_WINDOW\n        @timestamp < earliest\n\nclass ActivitySvc\n    constructor: (socket)->\n        @window = []\n        @mostRecent = 0\n        socket.$on 'window', (_)=> @setWindow _\n        socket.$on 'activity', (_)=> @addActivity _\n\n    setWindow: (window)->\n        @window = window.map (_)-> new Activity _\n        # TODO Reset sort bounds\n        @\n\n    getWindow: ->\n        @window.slice(@mostRecent)\n\n    addActivity: (data)->\n        @window.push new Activity data\n        @\n\n    checkActivity: ->\n        while not @window[@mostRecent].isInScope()\n            @mostRecent += 1\n        @\n\nActivitySvc.$inject = ['SocketSvc']\n\nangular.module('dolores.activity.service', [\n    'dolores.socket.service'\n]).service 'ActivitySvc', ActivitySvc\n\n```\n\nIn this program, an `Activity` is a timestamped list of things that have\nhappened in the system. The data isn't important, except that each data piece\nhas a `timestamp` field. The only business rule at this point is that pieces of\ndata older than a compile time threshold (currently 20 minutes) should not be\nincluded in the view, but should be available for metrics, debugging, etc.\n\nThis example uses `socket.io`, with one exception - the `$on` method was added\nto wrap `socket.io::on` in a call to `$rootScope.$apply`, letting Angular know\nsomething has happened.\n"
    },
    "/pages/04_client/01_organization/02_controllers/index.md": {
      "front": {
        "title": "Controllers",
        "path": "/pages/04_client/01_organization/02_controllers/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "### Problem\n\nWith a strong, consistent data model, there are still application specific logic\nconcerns, separate from the data model itself.\n\n### Solution\n\nAngular Controllers serve as the conceptual glue between a \n"
    },
    "/pages/04_client/01_organization/03_directives/index.md": {
      "front": {
        "path": "/pages/04_client/01_organization/03_directives/index.md",
        "title": "04_client01_organization/03_directives",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/04_client/01_organization/04_filters/index.md": {
      "front": {
        "path": "/pages/04_client/01_organization/04_filters/index.md",
        "title": "04_client01_organization/04_filters",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/04_client/01_organization/05_providers/index.md": {
      "front": {
        "path": "/pages/04_client/01_organization/05_providers/index.md",
        "title": "04_client01_organization/05_providers",
        "author": "David Souther",
        "date": null
      },
      "body": ""
    },
    "/pages/04_client/index.md": {
      "front": {
        "title": "Client",
        "path": "/pages/04_client/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "The client, in the MEAN stack, is anything that runs on a user's device, outside the server. In practice, this means code that is running in a browser, or in a WebView on a mobile device. Angular provides many framework utilities, including dependency injection for application management; a complete MVVM architecture; extensible HTML components; and a full http & REST suite. There are also many techniques to manage CSS, a common contributor of technical debt to large web applications.\n\n### Organization\n1. **Services**\n1. **Controllers**\n1. **Directives**\n1. **Filters**\n1. **Providers**\n\n### Data\n1. **$http**\n1. **$resource**\n1. **Restangular**\n1. **Sockets**\n\n### Forms\n1. **css**\n1. **ngModelOptions**\n1. **Custom Validation**\n1. **ngMessage**\n\n### Utility Directives\n1. **Using ngModel**\n1. **th(sort)**\n1. **select**\n\n### Styles\n1. **Bootstrap**\n1. **BEM**\n1. **all** / **print** / **screen**\n\n### Animation\n1. **css**\n1. **ngAnimate**\n1. **Staggering Animations**\n"
    },
    "/pages/05_advanced_client/index.md": {
      "front": {
        "title": "Advanced Client",
        "path": "/pages/05_advanced_client/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "Injecting outside the box, Angular provides a great paradigm to build fantastically rich user interfaces and components. These recipes should serve as a jumping off point for adding wicked functionality to your SPA.\n\n### Routing / History / State\n\n1. **ngRoute**\n1. **ui-router**\n\n### Complex UX Controls\n\n1. **Tables**\n1. **Modals**\n1. **Wizards**\n\n### Wrapping HTML5 as Services\n\n1. **LocalStorage**\n1. **FileReader**\n1. **Geolocation**\n1. **WebRTC** *Audio*, *Video*, *P2P*\n\n### Visualizations\n\n1. **d3 interop**\n1. **SVG**\n1. **WebGL**\n\n### Analytics\n\n1. **segment.io**\n\n### Security\n\n### Performance\n\n1. **3d rendering**\n"
    },
    "/pages/06_mobile/index.md": {
      "front": {
        "title": "Mobile",
        "path": "/pages/06_mobile/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "*Don't Be Crazy*\n\nBy following that simple rule, your SPA will work on a mobile device. With a few wrapper technologies, your SPA will be its own distributable, on both the Play and App stores. You can also distribute internally, for internal tools.\n\n### Application Cache\n\n### Rarely On\n\n### Ionic\n\n### Cordova\n\n1. **Bundling**\n1. **Installing**\n1. **Phone Features**\n"
    },
    "/pages/07_server/index.md": {
      "front": {
        "title": "Server",
        "path": "/pages/07_server/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "The Server is anything that runs on your hardware, in the cloud or data center. The server should focus only on providing an API for your business' data. Whether this is only privately accessible, or open for your customers to use responsibly, the server recipes will get you from zero to REST. The concepts are applicable across other server backends, and the flexibility of a RESTful API pays back in spades.\n\n### Logging\n1. **winston**\n1. **What to Log**\n\n### File System\n1. **fs**\n1. **Q.denodeify**\n\n### Mongo\n1. **mongo native driver**\n1. **mongoose-q**\n1. **express-restify-mongoose**\n\n### SQLite\n1. **node-sqlite3**\n1. **RESTify**\n\n### Passport\n1. **Local**\n1. **Google**\n1. **Locking down resources**\n"
    },
    "/pages/08_realtime/index.md": {
      "front": {
        "title": "Realtime",
        "path": "/pages/08_realtime/index.md",
        "author": "David Souther",
        "date": null
      },
      "body": "Realtime data takes a special level of consideration that cuts across the server and client.\n\n### Distributed Eventing\n\n### socket.io\n"
    },
    "/README.md": {
      "front": {
        "path": "/README.md",
        "title": "Home",
        "author": "David Souther",
        "date": null
      },
      "body": "# MEAN FAQ\n\nThe time of the Single Page App has come. Web development, even before Rails, has been well served by the 3-tier architecture. A web server runs Ruby, PHP, or Python pulls data from MySQL or Postgress, and renders a mostly static HTML asset. With the great strides in HTML5 browser technologies, since 2012 it's been feasible to build Single Page Applications. As of 2014, it's practical. A SPA, rather than sending rendered HTML for ever request, serves a bundle of static assets that contain code for the entire site. This code calls services for data via restful APIs, allowing much flexibility in a system's architecture. This approach can still be 3-tier, but the web tier handles data, not HTML.\n\nThis book will teach you a variety of techniques to build and iterate on SPAs quickly, and with confidence. There are numerous frameworks and technologies to choose between, for all layers of the SPA stack. One set, becoming a buzzword in itself, is the MEAN approach. A play on \"LAMP\", MEAN is a collection of technologies for building a SPA stack. *M*ongoDB is a schemaless, disk-backed database. *E*xpressJS is an extensible middleware based HTTP handler. *A*ngularJS is a powerful and expressive javascript framework. *N*odeJS is a highly asynchronous server platform written in Javascript. The MEAN approach takes some fantastic technologies and allows development teams to focus their efforts in Javascript. This provides real benefits to teams in following a single set of best practices. That said, the approach is highly decoupled, and teams can swap out any piece for a more appropriate technology as needed.\n\nAlas, in the arena of full-stack JS architectures, there is no single framework as solid as Ruby on Rails for building SPAs. This isn't a bad thing necessarily. Because the technologies for building SPAs are so easily decoupled, rather than providing a single architecture for every team to plug in to, it is better to learn where each of the pieces fit together, and how to use each effectively. This Cookbook is a collection of those best practices and techniques, taken from experience building these systems over the past few years. Taken a la cart, a team or developer can find good tutorials and info on building certain parts of their application. Taken as a whole, a team can build a full SPA stack that fits their business use case like a glove.\n"
    }
  }
}